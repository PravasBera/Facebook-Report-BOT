<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Facebook Automation Tool</title>
  <style>
    body { font-family: Inter, Arial; background:#f4f7fb; margin:0; padding:20px; color:#111; display:flex; flex-direction:column; min-height:100vh;}
    .card { background:white; border-radius:12px; padding:18px; box-shadow:0 6px 18px rgba(20,30,60,0.08); margin-bottom:16px;}
    header { font-size:20px; font-weight:700; color:#1869ff; margin-bottom:20px; display:flex;justify-content:space-between;align-items:center;}
    .meta { font-size:13px; color:#0b1220; opacity:0.8; text-align:right; }
    input[type=text], textarea { width:100%; padding:12px; border-radius:8px; border:1px solid #e4e8f0; box-sizing:border-box; }
    .radio-row { display:flex; gap:10px; margin:12px 0; }
    .options-list { display:block; margin-top:12px; }
    .option-item { display:flex; gap:12px; align-items:center; padding:12px; border-radius:10px; border:1px solid #eef2f7; margin-bottom:10px; background:#fff;}
    .btn { padding:10px 16px; border-radius:10px; cursor:pointer; border:none; font-weight:700;}
    .btn-primary { background:#1869ff; color:white; }
    .btn-ghost { background:transparent; border:1px solid #cfe0ff; color:#1869ff; }
    .flex { display:flex; gap:10px; align-items:center; }
    .small { font-size:13px; color:#666; }
    pre{ background:#0b1220; color:#0aff8d; padding:12px; border-radius:8px; max-height:300px; overflow:auto; white-space:pre-wrap; word-break:break-word;}
    footer { margin-top:auto; text-align:center; font-size:13px; color:#666; padding:12px 0; }
    .badge { font-size:12px; color:#fff; background:#06b6d4; padding:6px 8px; border-radius:8px;}
  </style>
</head>
<body>

<header>
  <div>
    ‚ö° <strong>Facebook Automation Tool</strong>
    <div style="font-size:12px;color:#444;margin-top:6px;">
      üë§ Author: <b>PRAVAS BERA</b> &nbsp;|&nbsp; üåç Version: <b>Premium</b> &nbsp;|&nbsp; üáÆüá≥ Country: <b>INDIA</b>
    </div>
    <div style="font-size:12px;color:#b45309;margin-top:6px;">üî• <b>INDIAN DANGER OF BULLET TEAM</b> üî•</div>
  </div>

  <div class="meta">
    <div class="small">Admin control panel</div>
    <div style="margin-top:8px;"><span class="badge">Ready</span></div>
  </div>
</header>

<div class="card">
  <label>Enter Admin Token here (x-admin-token)</label>
  <div style="display:flex; gap:8px; margin-top:8px;">
    <input id="adminToken" type="text" placeholder="x-admin-token" />
    <button id="saveToken" class="btn btn-ghost">Save</button>
  </div>
</div>

<div class="card">
  <div class="radio-row">
    <label><input type="radio" name="rtype" value="profile" checked> Profile</label>
    <label><input type="radio" name="rtype" value="page"> Page</label>
    <label><input type="radio" name="rtype" value="post"> Post</label>
  </div>

  <label>Target URL / ID</label>
  <input id="target" type="text" placeholder="https://facebook.com/..." />

  <div id="optionsBox" class="options-list"></div>

  <div style="margin-top:12px;">
    <label>Cookies upload</label><br/>
    <input id="cookiesFile" type="file" accept=".txt" />
    <div style="margin-top:8px;" class="flex">
      <button id="uploadCookies" class="btn btn-ghost">Upload Cookies</button>
      <button id="startBtn" class="btn btn-primary">Start</button>
      <button id="stopBtn" class="btn" style="background:#ff4d4f;color:white;">Stop</button>
    </div>
    <div class="small" style="margin-top:8px;">Each line in cookies.txt = one cookie string (fr=...; xs=...; c_user=...; ...)</div>
  </div>
</div>

<div class="card">
  <h4>Live Logs</h4>
  <div id="liveInfo" class="small">Selected: <span id="selectedCount">0</span></div>
  <pre id="logArea">No logs yet.</pre>
</div>

<footer>
  ¬© 2025 | Facebook Automation Tool | Developed With ‚ù§Ô∏è by BULLET TEAM ‚ò†Ô∏è
</footer>

<script>
  // --- option sets (exact same as you listed) ---
  const OPTION_SETS = {
    profile: ['Problem involving someone under 18','Bullying, harassment or abuse','Violent, hateful or disturbing content','Adult content','Fake profile'],
    page: ['Problem involving someone under 18','Bullying, harassment or abuse','Violent, hateful or disturbing content','Adult content','Fake page'],
    post: ['Problem involving someone under 18','Bullying, harassment or abuse','Violent, hateful or disturbing content','Adult content']
  };

  // DOM
  const adminInput = document.getElementById('adminToken');
  const saveToken = document.getElementById('saveToken');
  const optionsBox = document.getElementById('optionsBox');
  const startBtn = document.getElementById('startBtn');
  const stopBtn = document.getElementById('stopBtn');
  const logArea = document.getElementById('logArea');
  const selectedCount = document.getElementById('selectedCount');
  let currentJobId = null;
  let es = null;
  let cookiesText = null;
  let lastStartMode = null; // 'report' or 'start' (for SSE path)

  // load saved token
  adminInput.value = localStorage.getItem('adminToken') || '';

  saveToken.onclick = () => {
    localStorage.setItem('adminToken', adminInput.value.trim());
    alert('Admin token saved locally');
  };

  // render options
  function renderOptions(type){
    optionsBox.innerHTML = '';
    OPTION_SETS[type].forEach((opt,i)=>{
      const id = `${type}-opt-${i}`;
      const div = document.createElement('div');
      div.className = 'option-item';
      div.innerHTML = `<input type="checkbox" id="${id}" data-text="${opt}" /><label for="${id}">${opt}</label>`;
      optionsBox.appendChild(div);
    });
    attachOptionListeners();
  }

  function attachOptionListeners(){
    const checkboxes = optionsBox.querySelectorAll('input[type=checkbox]');
    checkboxes.forEach(ch=>ch.onchange = updateSelectedCount);
    updateSelectedCount();
  }
  function updateSelectedCount(){
    const sel = optionsBox.querySelectorAll('input[type=checkbox]:checked').length;
    selectedCount.textContent = sel;
  }

  document.querySelectorAll('input[name=rtype]').forEach(el=>{
    el.onchange = ()=> renderOptions(document.querySelector('input[name=rtype]:checked').value);
  });

  renderOptions('profile');

  // cookies file read
  document.getElementById('cookiesFile').onchange = async (e) => {
    const f = e.target.files[0]; if(!f) return;
    const txt = await f.text();
    cookiesText = txt.trim();
    appendLog(`‚úÖ cookies loaded (${cookiesText.split(/\r?\n/).length} lines)`);
  };

  // upload cookies to server (admin endpoint)
  document.getElementById('uploadCookies').onclick = async () => {
    const adminToken = adminInput.value.trim() || localStorage.getItem('adminToken') || '';
    if (!adminToken) return alert('Admin token required to upload cookies');
    const f = document.getElementById('cookiesFile').files[0];
    if (!f) return alert('Choose cookies .txt file first');
    const fd = new FormData();
    fd.append('cookies', f);
    appendLog('Uploading cookies...');
    try {
      const res = await fetch('/uploadCookies', { method: 'POST', headers: { 'x-admin-token': adminToken }, body: fd });
      const j = await res.json();
      if (j.ok) appendLog('‚úÖ Cookies uploaded to server: ' + (j.path || 'uploads/cookies.txt'));
      else appendLog('‚ùå Upload failed: ' + (j.message || j.error || JSON.stringify(j)));
    } catch (e) { appendLog('‚ùå Upload error: ' + e.message); }
  };

  // helpers
  function appendLog(text){
    const ts = new Date().toLocaleTimeString();
    logArea.textContent += `[${ts}] ${text}\n`;
    logArea.scrollTop = logArea.scrollHeight;
  }

  // start job: try /report first, fallback to /start
  startBtn.onclick = async () => {
    const adminToken = adminInput.value.trim() || localStorage.getItem('adminToken') || '';
    if (!adminToken) { alert('Set admin token'); return; }
    const type = document.querySelector('input[name=rtype]:checked').value;
    const target = document.getElementById('target').value.trim();
    if (!target) { alert('Set target URL/ID'); return; }
    const options = Array.from(optionsBox.querySelectorAll('input[type=checkbox]:checked')).map(i => i.dataset.text);
    if (!options.length) { if(!confirm('No specific report options selected ‚Äî continue?')) return; }

    // try /report (user earlier referenced it) ‚Äî this endpoint may be a custom one returning {ok:true, jobId}
    const payload = { type, target, options, cookies: cookiesText || null };
    appendLog('Attempting POST /report ...');
    try {
      const r = await fetch('/report', { method: 'POST', headers: {'Content-Type':'application/json','x-admin-token':adminToken}, body: JSON.stringify(payload) });
      if (r.status === 404) throw new Error('not-found');
      const j = await r.json();
      if (j.ok) {
        currentJobId = j.jobId || j.sessionId || ('job_' + Date.now());
        lastStartMode = 'report';
        appendLog('‚úÖ /report accepted ‚Äî jobId: ' + currentJobId);
        connectSSEForJob(currentJobId);
        return;
      } else {
        appendLog('‚ùå /report failed: ' + (j.message || JSON.stringify(j)));
        // fallback to /start below
      }
    } catch (e) {
      appendLog('‚ö† /report unavailable or error: ' + e.message + ' ‚Äî falling back to /start');
    }

    // --- fallback: call /start (server.js expects {sessionId,targetUrl,setType,setId}) ---
    try {
      const body = { sessionId: 'ui', targetUrl: target, setType: type, setId: '' };
      appendLog('Posting to /start (fallback) ...');
      const r2 = await fetch('/start', { method: 'POST', headers: {'Content-Type':'application/json','x-admin-token':adminToken}, body: JSON.stringify(body) });
      const j2 = await r2.json();
      if (j2.ok) {
        currentJobId = 'ui';
        lastStartMode = 'start';
        appendLog('‚úÖ /start accepted ‚Äî using sessionId: ui');
        connectSSEForJob('ui');
      } else {
        appendLog('‚ùå /start failed: ' + (j2.message || JSON.stringify(j2)));
        alert('Start failed: ' + (j2.message || JSON.stringify(j2)));
      }
    } catch (err) {
      appendLog('‚ùå start request error: ' + err.message);
      alert('Network error: ' + err.message);
    }
  };

  // stop job
  stopBtn.onclick = async () => {
    const adminToken = adminInput.value.trim() || localStorage.getItem('adminToken') || '';
    if (!adminToken) { alert('Admin token required'); return; }

    // if lastStartMode was report and we have jobId -> try /stop with jobId or sessionId
    appendLog('Sending stop request ...');
    try {
      // try generic /stop with sessionId 'ui' or jobId if set
      const sid = currentJobId || 'ui';
      const res = await fetch('/stop', { method: 'POST', headers: {'Content-Type':'application/json','x-admin-token':adminToken}, body: JSON.stringify({ sessionId: sid, jobId: currentJobId }) });
      const j = await res.json();
      appendLog((j.ok ? '‚úÖ Stop requested' : ('‚ùå Stop failed: ' + (j.message || JSON.stringify(j)))));
    } catch (e) {
      appendLog('‚ùå Stop error: ' + e.message);
    } finally {
      disconnectSSE();
    }
  };

  // SSE connection helper (works with server's /events?sessionId=...)
  function connectSSEForJob(jobId) {
    disconnectSSE();
    // normalize jobId -> use as sessionId param
    const sid = encodeURIComponent(jobId || 'ui');
    const url = `/events?sessionId=${sid}`;
    appendLog('Connecting SSE -> ' + url);
    try {
      es = new EventSource(url);
      es.onopen = () => appendLog('SSE connected');
      es.onmessage = e => {
        // some servers send plain text or JSON in data; try JSON parse
        try {
          const d = JSON.parse(e.data);
          appendLog('[msg] ' + (d.msg || JSON.stringify(d)));
        } catch (err) {
          appendLog('[raw] ' + e.data);
        }
      };
      ['log','info','warn','error','success','done','fatal'].forEach(ev=>{
        es.addEventListener(ev, e => {
          try {
            const p = JSON.parse(e.data);
            appendLog(`[${ev}] ${p.msg || JSON.stringify(p)}`);
          } catch {
            appendLog(`[${ev}] ${e.data}`);
          }
        });
      });
      es.onerror = (ev) => { appendLog('[SSE] connection error/closed'); es.close(); };
    } catch (err) {
      appendLog('SSE error: ' + err.message);
    }
  }

  function disconnectSSE(){
    if (es) {
      try { es.close(); } catch {}
      es = null;
      appendLog('SSE disconnected');
    }
    currentJobId = null;
  }

  // ensure we disconnect when page unloads
  window.addEventListener('beforeunload', () => { disconnectSSE(); });
</script>
</body>
</html>
